#!/bin/bash

##############################################################################
# Build Results

function zeal_notes()
{
  git notes --ref refs/notes/zeal "$@" 2>/dev/null
  return $?
}

function zeal_clear_build_result()
{
  local object="$1"
  zeal_notes remove --ignore-missing "$object"
  return $?
}

function zeal_set_build_result()
{
  local object
  local build_log=/dev/null
  local -a vars
  while [[ $# -ne 0 ]]; do
    case "$1" in
      -e|--exit)     shift; vars[${#vars[@]}]="exit=$1";;
      -e*)           vars[${#vars[@]}]="exit=${1#-e}";;
      --exit=*)      vars[${#vars[@]}]="exit=${1#--exit=}";;

      -l|--log)      shift; build_log="$1";;
      -l*)           build_log="${1#-l}";;
      --log=*)       build_log="${1#--log=}";;

      -v|--variable) shift; vars[${#vars[@]}]="$1";;
      -v*)           vars[${#vars[@]}]="${1#-v}";;
      --variable=*)  vars[${#vars[@]}]="${1#--variable=}";;

      -*)
        printf 'git zeal set-build-result: unknown option "%s".\n' "$1" >&2
        return 1
        ;;

      *)
        if [[ -n "$object" ]]; then
          printf 'git zeal set-build-result: only one object allowed.\n' >&2
          return 1
        fi
        object="$1"
        ;;

    esac
    shift
  done

  if [[ -z "$object" ]]; then
    printf 'git zeal set-build-result: no object supplied.\n' >&2
    return 1
  fi

  (
    for var in "${vars[@]}"; do
      printf '%s\n' "$var"
    done
    printf '\n'
    cat "$build_log"
  ) | zeal_notes add -f -F- "$object"
  return $?
}

function zeal_show_build_result()
{
  local object
  local what=all
  local var_prefix=''
  local shell=no
  while [[ $# -ne 0 ]]; do
    case "$1" in
      -l|--log)   what=log;;
      -s|--shell) shell=yes;;
      -v|--vars)  what=vars;;

      --var-prefix)   shift; var_prefix="$1";;
      --var-prefix=*) var_prefix="${1#--var-prefix=}";;

      -*)
        printf 'git zeal show-build-result: unknown option "%s".\n' "$1" >&2
        return 1
        ;;

      *)
        if [[ -n "$object" ]]; then
          printf 'git zeal show-build-result: only one object allowed.\n' >&2
          return 1
        fi
        object="$1"
        ;;
    esac
    shift
  done

  if [[ -z "$object" ]]; then
    printf 'git zeal show-build-result: no object supplied.\n' >&2
    return 1
  fi

  local -a sed_exprs=()

  if [[ x$shell = xyes ]]; then
    sed_exprs+=( '-e' '1,/^$/{
      /^$/!{
        s/'\''/'\''\\'\'\''/g
        s/=\(.*\)$/='\''\1'\''/
      }
    }' )
  fi

  if [[ -n "$var_prefix" ]]; then
    sed_exprs+=( '-e' '1,/^$/{
      /^$/!{
        s/^/'"$var_prefix"'/
      }
    }' )
  fi

  case "$what" in
    vars) sed_exprs+=( '-e' '/^$/,$d' );;
    log)  sed_exprs+=( '-e' '1,/^$/d' );;
  esac

  zeal_notes show "$object" | sed "${sed_exprs[@]}"
  return $?
}

##############################################################################

function find_commits()
{
  local -a q=( "$(git rev-parse "$1")" )
  local -i i=0 end=1
  while (( i < end && end < 10 )); do
    local top="${q[i++]}"

    local zeal_build_var_exit=-1
    eval "$(zeal_show_build_result --vars --var-prefix=zeal_build_var_ --shell "$top")"
    if [[ $zeal_build_var_exit -eq 0 ]]; then
      continue
    fi
    for parent in $(git rev-parse "${top}^@"); do
      q[end++]=$parent
    done
  done

  for (( j = i - 1; j >= 0; j-- )); do
    printf '%s\n' "${q[j]}"
  done
}

function zeal_status()
{
  git for-each-ref --format='%(refname:short)' refs/heads/ | \
  while read refname; do
    printf ' %s\n' "$refname"
    for commit in $(find_commits "$refname"); do
      local -i zeal_build_var_exit=-1
      eval "$(zeal_show_build_result --vars --var-prefix=zeal_build_var_ --shell "$commit")"
      local status
      if (( zeal_build_var_exit == -1 )); then
        status='??'
      elif (( zeal_build_var_exit == 0 )); then
        status='OK'
      else
        status='XX'
      fi
      printf '   [%2s] %s %s\n' \
        "$status" \
        "$(git rev-parse --short "$commit")" \
        "$(git log -1 --pretty=%s "$commit")"
    done
  done
}

function zeal_build()
{
  local object="${1:-HEAD}"

  local build_command=$(git config --get zeal.build-command)
  if [[ -z $build_command ]]; then
    printf 'git zeal build: zeal.build-command not set.\n' >&2
    return 1
  fi

  local -i start=$(date +%s)
  zeal_set_build_result -v start=$start "$object"

  local build_dir=$(mktemp -d -t zeal)
  local build_log=$(mktemp -t zeal-log)
  git worktree add -f --detach "$build_dir" "$object" || return $?

  pushd "$build_dir" || return $?

  eval "$build_command" |tee "$build_log"
  local -i build_exit=$?

  popd
  local -i end=$(date +%s)

  zeal_set_build_result \
    -e "$build_exit" \
    -l "$build_log" \
    -v start=$start \
    -v end=$end \
    "$object" || return $?

  rm -rf "$build_dir" "$build_log"
  return $?
}

function zeal_next()
{
  # HEAD always gets priority
  if [[ -z "$(read_mark HEAD)" ]]
  then
    git rev-parse HEAD
    return 0
  fi

  # Next, find an untested branch tip
  git for-each-ref --format='%(refname)' refs/heads/ | \
  while read refname
  do
    local commit=$(git rev-parse "$refname")
    if [[ "$(read_mark "$commit")" != "ok" ]]
    then
      echo "$commit"
      return 0
    fi
  done

  # Nothing
  return 1
}

command="${1//-/_}"
shift
"zeal_${command}" "$@"
exit $?
