# General Settings
# ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾

set-option global autoreload yes
set-option global grepcmd 'ag --column'

hook global BufWritePre .* %{ nop %sh{ mkdir -p $(dirname "$kak_hook_param") }}

# Appearance
# ‾‾‾‾‾‾‾‾‾‾

colorscheme desertex

set-option global ui_options ncurses_assistant=none ncurses_status_on_top=true ncurses_set_title=false

add-highlighter global/matching show-matching

set-face global LineNumbersWrapped black

set-face global Whitespace rgb:333333+f
add-highlighter global/whitespace show-whitespaces -spc ' ' -tab '➤' -lf '↩'

hook global WinSetOption filetype=(?!tmux-copy).* %{
    try %{ add-highlighter window/number number-lines }
}
hook global WinSetOption filetype=tmux-copy %{
    try %{ remove-highlighter window/number }
}

# Stolen from mawww
declare-option -hidden regex curword
set-face global CurWord default,rgb:4a4a4a

hook global NormalIdle .* %{
    eval -draft %{ try %{
        exec <space><a-i>w <a-k>\A\w+\z<ret>
        set-option buffer curword "\b\Q%val{selection}\E\b"
    } catch %{
        set-option buffer curword ''
    } }
}
add-highlighter global/ dynregex '%opt{curword}' 0:CurWord

# System clipboard handling
# ─────────────────────────

evaluate-commands %sh{
    case $(uname) in
        Linux) copy="xclip -i"; paste="xclip -o" ;;
        Darwin)  copy="pbcopy"; paste="pbpaste" ;;
    esac

    printf "map global user -docstring 'paste (after) from clipboard' p '!%s<ret>'\n" "$paste"
    printf "map global user -docstring 'paste (before) from clipboard' P '<a-!>%s<ret>'\n" "$paste"
    printf "map global user -docstring 'yank to clipboard' y '<a-|>%s<ret>:echo -markup %%{{Information}copied selection to system clipboard}<ret>'\n" "$copy"
    printf "map global user -docstring 'replace from clipboard' R '|%s<ret>'\n" "$paste"
}

# Soft tabs
# ‾‾‾‾‾‾‾‾‾

define-command -params 0 expand-tabs %{
    hook -group expand-tabs window InsertChar \t %{ try %{
        execute-keys -draft "h<a-h><a-k>\A\h+\z<ret><a-;>;%opt{indentwidth}@"
    } }
    hook -group expand-tabs window InsertDelete ' ' %{ try %{
        execute-keys -draft "h<a-h><a-k>\A\h+\z<ret>i<space><esc><lt>"
    } }
}

define-command -params 0 keep-tabs %{
    remove-hooks window expand-tabs
}

hook global WinSetOption filetype=(?!makefile).* expand-tabs
hook global WinSetOption filetype=makefile keep-tabs

# Find
# ‾‾‾‾

define-command -docstring 'Find a file' -params 1 -shell-script-candidates %{ag -l -f} find %{ edit %arg{@} }

# Jump
# ‾‾‾‾

declare-option -hidden str jump_search_result

define-command -hidden -params 1 jump-helper %{
    evaluate-commands %sh{
        if [ "$1" -ef "${kak_buffile}" ]; then
            printf 'set-option global jump_search_result "%s"\n' "${kak_client}"
        fi
    }
}

define-command -override \
    -docstring %{jump [<options>] <file> [<line> [<column>]]

Takes all the same switches as edit.} \
    -params 1..3 \
    -file-completion \
    jump %{
    set-option global jump_search_result %opt{jumpclient}
    evaluate-commands %sh{
        for client in ${kak_client_list}; do
            echo "evaluate-commands -client \"${client}\" %{jump-helper \"$1\"}"
        done
    }
    evaluate-commands -try-client %opt{jump_search_result} %{
        edit %arg{@}
        try %{ focus }
    }
}

# Layout
# ‾‾‾‾‾‾

declare-option -hidden str-list tmux_client_info

define-command -hidden tmux-visit-client %{
    evaluate-commands %sh{
        if [ -n "${kak_client_env_TMUX}" ] && [ -n "${kak_client_env_TMUX_PANE}" ]; then
            printf 'set-option -add global tmux_client_info %%{%s} %%{%s} %%{%s}\n' "${kak_client}" "${kak_client_env_TMUX}" "${kak_client_env_TMUX_PANE}"
        fi
    }
}

define-command -hidden tmux-collect-client-info %{
    set-option global tmux_client_info
    evaluate-commands %sh{
        for client in ${kak_client_list}; do
            printf 'evaluate-commands -client "%s" tmux-visit-client\n' "${client}"
        done
    }
}

define-command update-client-options %{
    tmux-collect-client-info
    evaluate-commands %sh{
        toolsclient=
        toolsclient_left=-1
        toolsclient_top=999999

        # Best client for tools client is upper-righthand corner
        eval set -- "${kak_opt_tmux_client_info}"
        while [ $# -gt 0 ]; do
            client="$1"; shift
            TMUX="$1"; shift
            TMUX_PANE="$1"; shift
            export TMUX TMUX_PANE

            pane_position=$(tmux display-message -t "${TMUX_PANE}" -p -F '#{pane_top}.#{pane_left}')
            pane_top="${pane_position%.*}"
            pane_left="${pane_position#*.}"

            accept=no
            if [ $pane_left -gt $toolsclient_left ]; then
                accept=yes
            elif [ $pane_left -eq $toolsclient_left ] && [ $pane_top -lt $toolsclient_top ]; then
                accept=yes
            fi

            if [ $accept = yes ]; then
                toolsclient=$client
                toolsclient_left=$pane_left
                toolsclient_top=$pane_top
            fi
        done

        jumpclient=
        jumpclient_left=-1
        jumpclient_top=999999

        # Best client for jumpclient is just to left of toolsclient
        eval set -- "${kak_opt_tmux_client_info}"
        while [ $# -gt 0 ]; do
            client="$1"; shift
            TMUX="$1"; shift
            TMUX_PANE="$1"; shift
            export TMUX TMUX_PANE

            pane_position=$(tmux display-message -t "${TMUX_PANE}" -p -F '#{pane_top}.#{pane_left}')
            pane_top="${pane_position%.*}"
            pane_left="${pane_position#*.}"

            accept=no
            if [ $pane_left -lt $toolsclient_left ] && [ $pane_left -gt $jumpclient_left ]; then
                accept=yes
            elif [ $pane_left -eq $jumpclient_left ] && [ $pane_top -lt $jumpclient_top ]; then
                accept=yes
            fi

            if [ $accept = yes ]; then
                jumpclient=$client
                jumpclient_left=$pane_left
                jumpclient_top=$pane_top
            fi
        done

        # REPL pane is in the lower, right-hand corner
        repl_pane=
        repl_pane_left=-1
        repl_pane_top=-1
        tmux list-panes -F '#{pane_top} #{pane_left} #{pane_id}' | {
            while read pane_top pane_left pane_id; do
                accept=no
                if [ $pane_left -gt $repl_pane_left ]; then
                    accept=yes
                elif [ $pane_left -eq $repl_pane_left ] && [ $pane_top -gt $repl_pane_top ]; then
                    accept=yes
                fi

                if [ $accept = yes ]; then
                    repl_pane="$pane_id"
                    repl_pane_left=$pane_left
                    repl_pane_top=$pane_top
                fi
            done
            if [ -n "$repl_pane" ]; then
                printf 'set-option global tmux_repl_id %%{%s}\n' "$repl_pane"
            fi
        }

        if [ -n "$toolsclient" ]; then
            printf 'set-option global toolsclient "%s"\n' "$toolsclient"
        fi
        if [ -n "$jumpclient" ]; then
            printf 'set-option global jumpclient "%s"\n' "$jumpclient"
        fi
    }
}

hook -group client-tracker global NormalIdle .* update-client-options

# Open Nearest Link
# ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾

define-command \
    -docstring %{open-nearest-link: find a link on or after the cursor and open it} \
    open-nearest-link %{
    evaluate-commands -draft %{
        try %{
            execute-keys '<a-i><a-w><a-k>https?://<ret>'
            execute-keys '<a-|>xargs open<ret>'
        } catch %{
            execute-keys '/\bhttps?://[^\s]*<ret>'
            execute-keys '<a-|>xargs open<ret>'
        } catch %{
            echo -markup '{Error}no URL found.'
        }
    }
}

map global user o ': open-nearest-link<ret>'

# Normal Mode
# ‾‾‾‾‾‾‾‾‾‾‾

map global normal * '<a-i>w"/yn'
map global normal <a-*> '<a-i>w"/y<a-n>'

# tmux
# ‾‾‾‾

define-command -hidden -override -params 2.. tmux-terminal-impl %{
    evaluate-commands %sh{
        tmux=${kak_client_env_TMUX:-$TMUX}
        if [ -z "$tmux" ]; then
            echo "fail 'This command is only available in a tmux session'"
            exit
        fi
        tmux_args="$1"
        shift
        # ideally we should escape single ';' to stop tmux from interpreting it as a new command
        # but that's probably too rare to care
        keys=""
        while [ $# -gt 0 ]; do
            keys="$keys '$(printf %s "$1" |sed -e "s/\'/\'\\\'\'/g")'"
            shift
        done
        keys="$keys ; exit 0
"
        TMUX=$tmux tmux $tmux_args env TMPDIR="$TMPDIR" ${kak_client_env_SHELL:-/bin/sh} -l \; send-keys -l "$keys"
    }
}

# Clojure
# ‾‾‾‾‾‾‾

define-command -params 0 -docstring %{Clojure form object
Expects %reg{s} to be the input selection.  Sets %reg{w} to the whole form and
%reg{i} to inside the form.} \
    clojure-form-object %{
    evaluate-commands -draft %{
        try %{ execute-keys %{"sz<a-a>c(?:#\?@?\s*|[#@`']\s*)?\(,\)<ret>} %{"wZ} }
        try %{ execute-keys %{"sz<a-a>c(?:#[^\s()\[\]{}"\\\\%/]+(?:/[^\s()\[\]{}"\\\\%/]+)?\s*)?\[,\]<ret>} %{"w<a-Z>-} }
        try %{ execute-keys %{"sz<a-a>c(?:} \
            %{#|} \
            %{#[^\s()\[\]{}"\\\\%/]+(?:/[^\s()\[\]{}"\\\\%/]+)?\s*} | \
            %{#:[^\s()\[\]{}"\\\\%/]+\s*} | \
            %{\^\s*} \
            %{)?\{,\}<ret>} %{"w<a-Z>-} }
        try %{
            execute-keys %{"wz} %{s\A(?:} \
                %<(?:#\?@?\s*|[#@`']\s*)?\(\K.*(?=\))> | \
                %<(?:#[^\s()\[\]{}"\\\\%/]+(?:/[^\s()\[\]{}"\\\\%/]+)?\s*)?\[\K.*(?=\])> | \
                %<(?:#|#[^\s()\[\]{}"\\\\%/]+(?:/[^\s()\[\]{}"\\\\%/]+)?\s*|\^\s*)?\{\K.*(?=\}))> \
                %{)<ret>} %{"iZ}
        }
    }
}

define-command -hidden clojure-toplevel-form-object-helper %{
    set-register s %reg{w}
    clojure-form-object
    try %{
        execute-keys -draft '"wz'
        set-register x %reg{w}
        set-register j %reg{i}
        evaluate-commands %sh{
            if ! [ "$kak_reg_w" = "$kak_reg_s" ]; then
                echo clojure-toplevel-form-object-helper
            fi
        }
    }
}

define-command -params 0 -docstring %{Clojure top-level form object
Expects %reg{s} to be the input selection.  Sets %reg{w} to the whole form and
%reg{i} to inside the form.} \
    clojure-toplevel-form-object %{
    clojure-form-object
    evaluate-commands -save-regs sxj %{
        set-register x %reg{w}
        set-register j %reg{i}
        clojure-toplevel-form-object-helper
        set-register w %reg{x}
        set-register i %reg{j}
    }
}

define-command define-object-commands -params 1 %{
    evaluate-commands %sh{
        object_command="$1"
        prefix="${1%%-*}"
        name="${1%-object}"
        name="${name#*-}"
        for method in select extend; do
            for scope in whole inside; do
                for ends in start end both; do
                    cmd="${prefix}-${method}"
                    if ! [ $ends = both ]; then
                        cmd="${cmd}-to"
                    fi
                    cmd="${cmd}-${scope}-${name}"
                    if ! [ $ends = both ]; then
                        cmd="${cmd}-${ends}"
                    fi
                    reg=w
                    if [ $scope = inside ]; then
                        reg=i
                    fi
                    dir='<a-:>'
                    if [ $ends = start ]; then
                        dir='<a-:><a-;>'
                    fi
                    merge_keys=z
                    if [ $method = extend ]; then
                        merge_keys='<a-z>u'
                    fi
                    filter=''
                    if [ $ends = start ]; then
                        filter="
                            execute-keys '\"sZ\"oz'
                            evaluate-commands -itersel -save-regs x %{
                                execute-keys '\"xZ\"s<a-z>iGk\"x<a-z>i'
                            }
                            execute-keys '\"oZ\"sz'
                        "
                    elif [ $ends = end ]; then
                        filter="
                            execute-keys '\"sZ\"oz'
                            evaluate-commands -itersel -save-regs x %{
                                execute-keys '\"xZ\"s<a-z>iGj<a-L>\"x<a-z>i'
                            }
                            execute-keys '\"oZ\"sz'
                        "
                    fi
                    printf %s "
                        define-command -params 0 ${cmd} %{
                            evaluate-commands -save-regs 'wios' %{
                                set-register w
                                set-register i
                                execute-keys '\"sZ'
                                ${object_command}
                                set-register o %reg{${reg}}
                                ${filter}
                                execute-keys '\"o${merge_keys}' '${dir}'
                            }
                        }
                        "
                done
            done
        done
        printf %s "
            define-command -hidden -params 0 ${object_command}-handler %{ objectify %{
                '<a-a>' ${prefix}-select-whole-${name}
                '['     ${prefix}-select-to-whole-${name}-start
                ']'     ${prefix}-select-to-whole-${name}-end
                '{'     ${prefix}-extend-to-whole-${name}-start
                '}'     ${prefix}-extend-to-whole-${name}-end
                '<a-i>' ${prefix}-select-inside-${name}
                '<a-[>' ${prefix}-select-to-inside-${name}-start
                '<a-]>' ${prefix}-select-to-inside-${name}-end
                '<a-{>' ${prefix}-extend-to-inside-${name}-start
                '<a-}>' ${prefix}-extend-to-inside-${name}-end
            } }
            "
    }
}

define-object-commands clojure-form-object
define-object-commands clojure-toplevel-form-object

hook global WinSetOption filetype=clojure %{
    set-option window indentwidth 2
    map -docstring 'Clojure form'           window object f '<esc>: clojure-form-object-handler<ret>'
    map -docstring 'top-level Clojure form' window object t '<esc>: clojure-toplevel-form-object-handler<ret>'
}
