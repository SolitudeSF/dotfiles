# General Settings
# ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾

set-option global autoreload yes
set-option global grepcmd 'ag --column'

hook global BufWritePre .* %{ nop %sh{ mkdir -p $(dirname "$kak_hook_param") }}

# Appearance
# ‾‾‾‾‾‾‾‾‾‾

colorscheme desertex

set-option global ui_options ncurses_assistant=none ncurses_status_on_top=true ncurses_set_title=false

add-highlighter global/matching show-matching

set-face global LineNumbersWrapped black

set-face global Whitespace rgb:333333+f
add-highlighter global/whitespace show-whitespaces -spc ' ' -tab '➤' -lf '↩'

hook global WinSetOption filetype=(?!tmux-copy).* %{
    try %{ add-highlighter window/number number-lines }
}
hook global WinSetOption filetype=tmux-copy %{
    try %{ remove-highlighter window/number }
}

# Stolen from mawww
declare-option -hidden regex curword
set-face global CurWord default,rgb:4a4a4a

hook global NormalIdle .* %{
    eval -draft %{ try %{
        exec <space><a-i>w <a-k>\A\w+\z<ret>
        set-option buffer curword "\b\Q%val{selection}\E\b"
    } catch %{
        set-option buffer curword ''
    } }
}
add-highlighter global/ dynregex '%opt{curword}' 0:CurWord

# System clipboard handling
# ─────────────────────────

evaluate-commands %sh{
    case $(uname) in
        Linux) copy="xclip -i"; paste="xclip -o" ;;
        Darwin)  copy="pbcopy"; paste="pbpaste" ;;
    esac

    printf "map global user -docstring 'paste (after) from clipboard' p '!%s<ret>'\n" "$paste"
    printf "map global user -docstring 'paste (before) from clipboard' P '<a-!>%s<ret>'\n" "$paste"
    printf "map global user -docstring 'yank to clipboard' y '<a-|>%s<ret>:echo -markup %%{{Information}copied selection to system clipboard}<ret>'\n" "$copy"
    printf "map global user -docstring 'replace from clipboard' R '|%s<ret>'\n" "$paste"
}

# Soft tabs
# ‾‾‾‾‾‾‾‾‾

define-command -params 0 expand-tabs %{
    hook -group expand-tabs window InsertChar \t %{ try %{
        execute-keys -draft "h<a-h><a-k>\A\h+\z<ret><a-;>;%opt{indentwidth}@"
    } }
    hook -group expand-tabs window InsertDelete ' ' %{ try %{
        execute-keys -draft "h<a-h><a-k>\A\h+\z<ret>i<space><esc><lt>"
    } }
}

define-command -params 0 keep-tabs %{
    remove-hooks window expand-tabs
}

hook global WinSetOption filetype=(?!makefile).* expand-tabs
hook global WinSetOption filetype=makefile keep-tabs

# Find
# ‾‾‾‾

define-command -docstring 'Find a file' -params 1 -shell-script-candidates %{ag -l -f} find %{ edit %arg{@} }

# Jump
# ‾‾‾‾

declare-option -hidden str jump_search_result

define-command -hidden -params 1 jump-helper %{
    evaluate-commands %sh{
        if [ "$1" -ef "${kak_buffile}" ]; then
            printf 'set-option global jump_search_result "%s"\n' "${kak_client}"
        fi
    }
}

define-command -override \
    -docstring %{jump [<options>] <file> [<line> [<column>]]

Takes all the same switches as edit.} \
    -params 1..3 \
    -file-completion \
    jump %{
    set-option global jump_search_result %opt{jumpclient}
    evaluate-commands %sh{
        for client in ${kak_client_list}; do
            echo "evaluate-commands -client \"${client}\" %{jump-helper \"$1\"}"
        done
    }
    evaluate-commands -try-client %opt{jump_search_result} %{
        edit %arg{@}
        try %{ focus }
    }
}

# Layout
# ‾‾‾‾‾‾

declare-option -hidden str-list tmux_client_info

define-command -hidden tmux-visit-client %{
    evaluate-commands %sh{
        if [ -n "${kak_client_env_TMUX}" ] && [ -n "${kak_client_env_TMUX_PANE}" ]; then
            printf 'set-option -add global tmux_client_info %%{%s} %%{%s} %%{%s}\n' "${kak_client}" "${kak_client_env_TMUX}" "${kak_client_env_TMUX_PANE}"
        fi
    }
}

define-command -hidden tmux-collect-client-info %{
    set-option global tmux_client_info
    evaluate-commands %sh{
        for client in ${kak_client_list}; do
            printf 'evaluate-commands -client "%s" tmux-visit-client\n' "${client}"
        done
    }
}

define-command update-client-options %{
    tmux-collect-client-info
    evaluate-commands %sh{
        toolsclient=
        toolsclient_left=-1
        toolsclient_top=999999

        # Best client for tools client is upper-righthand corner
        eval set -- "${kak_opt_tmux_client_info}"
        while [ $# -gt 0 ]; do
            client="$1"; shift
            TMUX="$1"; shift
            TMUX_PANE="$1"; shift
            export TMUX TMUX_PANE

            pane_position=$(tmux display-message -t "${TMUX_PANE}" -p -F '#{pane_top}.#{pane_left}')
            pane_top="${pane_position%.*}"
            pane_left="${pane_position#*.}"

            accept=no
            if [ $pane_left -gt $toolsclient_left ]; then
                accept=yes
            elif [ $pane_left -eq $toolsclient_left ] && [ $pane_top -lt $toolsclient_top ]; then
                accept=yes
            fi

            if [ $accept = yes ]; then
                toolsclient=$client
                toolsclient_left=$pane_left
                toolsclient_top=$pane_top
            fi
        done

        jumpclient=
        jumpclient_left=-1
        jumpclient_top=999999

        # Best client for jumpclient is just to left of toolsclient
        eval set -- "${kak_opt_tmux_client_info}"
        while [ $# -gt 0 ]; do
            client="$1"; shift
            TMUX="$1"; shift
            TMUX_PANE="$1"; shift
            export TMUX TMUX_PANE

            pane_position=$(tmux display-message -t "${TMUX_PANE}" -p -F '#{pane_top}.#{pane_left}')
            pane_top="${pane_position%.*}"
            pane_left="${pane_position#*.}"

            accept=no
            if [ $pane_left -lt $toolsclient_left ] && [ $pane_left -gt $jumpclient_left ]; then
                accept=yes
            elif [ $pane_left -eq $jumpclient_left ] && [ $pane_top -lt $jumpclient_top ]; then
                accept=yes
            fi

            if [ $accept = yes ]; then
                jumpclient=$client
                jumpclient_left=$pane_left
                jumpclient_top=$pane_top
            fi
        done

        # REPL pane is in the lower, right-hand corner
        repl_pane=
        repl_pane_left=-1
        repl_pane_top=-1
        tmux list-panes -F '#{pane_top} #{pane_left} #{pane_id}' | {
            while read pane_top pane_left pane_id; do
                accept=no
                if [ $pane_left -gt $repl_pane_left ]; then
                    accept=yes
                elif [ $pane_left -eq $repl_pane_left ] && [ $pane_top -gt $repl_pane_top ]; then
                    accept=yes
                fi

                if [ $accept = yes ]; then
                    repl_pane="$pane_id"
                    repl_pane_left=$pane_left
                    repl_pane_top=$pane_top
                fi
            done
            if [ -n "$repl_pane" ]; then
                printf 'set-option global tmux_repl_id %%{%s}\n' "$repl_pane"
            fi
        }

        if [ -n "$toolsclient" ]; then
            printf 'set-option global toolsclient "%s"\n' "$toolsclient"
        fi
        if [ -n "$jumpclient" ]; then
            printf 'set-option global jumpclient "%s"\n' "$jumpclient"
        fi
    }
}

hook -group client-tracker global NormalIdle .* update-client-options

# Open Nearest Link
# ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾

define-command \
    -docstring %{open-nearest-link: find a link on or after the cursor and open it} \
    open-nearest-link %{
    evaluate-commands -draft %{
        try %{
            execute-keys '<a-i><a-w><a-k>https?://<ret>'
            execute-keys '<a-|>xargs open<ret>'
        } catch %{
            execute-keys '/\bhttps?://[^\s]*<ret>'
            execute-keys '<a-|>xargs open<ret>'
        } catch %{
            echo -markup '{Error}no URL found.'
        }
    }
}

map global user o ': open-nearest-link<ret>'

# Normal Mode
# ‾‾‾‾‾‾‾‾‾‾‾

map global normal * '<a-i>w"/yn'
map global normal <a-*> '<a-i>w"/y<a-n>'

# Clojure
# ‾‾‾‾‾‾‾

define-command \
    -override \
    -params 0..0 \
    -docstring %{Clojure form object
Sets the 'w' register to the whole form and 'i' to inside the form.} \
    clojure-form-object %{
    evaluate-commands -save-regs 's' %{
        execute-keys '"sZ'
        try %{ execute-keys %{<a-a>c(?:#\?@?\s*|[#@`']\s*)?\(,\)<ret>} '"wZ' }
        try %{ execute-keys '"sz<a-a>r' '"w<a-Z>-' }
        try %{ execute-keys '"sz<a-a>c(?:#|\^\s*)?\{,\}<ret>' '"w<a-Z>-' }
        try %{
            execute-keys -draft '"wz'
        } catch %{
            fail 'no Clojure form at cursor'
        }
        try %{
            execute-keys '"wz' 's\A(?:' \
                %<(?:#\?@?\s*|[#@`']\s*)?\(\K.*(?=\))> '|' \
                %<\[\K.*(?=\])> '|' \
                %<(?:#|\^\s*)?\{\K.*(?=\}))> \
                ')<ret>' '"iZ'
        }
        execute-keys '"sz'
    }
}

define-command -override -params 2 execute-text-object %{
    evaluate-commands -save-regs 'wi' %{
        set-register w ''
        set-register i ''
        %arg{1}
        execute-keys '"' %arg{2} 'z<a-:>'
    }
}

define-command -params 0..0 -docstring 'select whole Clojure form' clojure-select-whole-form %{
    execute-text-object clojure-form-object w
}

define-command -params 0..0 -docstring 'select inside Clojure form' clojure-select-inside-form %{
    execute-text-object clojure-form-object i
}

define-command -hidden clojure-form-object-handler %{ objectify %{
    '<a-a>' clojure-select-whole-form
    '<a-i>' clojure-select-inside-form
} }

define-command \
    -override \
    -params 0..0 \
    -docstring 'select top-level Clojure form' \
    clojure-select-whole-toplevel-form %{
    try %{
        clojure-select-whole-form
        try clojure-select-whole-toplevel-form
    } catch %{
        execute-keys 'm'
    } catch %{
        fail 'no Clojure top-level form here'
    }
    execute-keys '<a-:>'
}

hook global WinSetOption filetype=clojure %{
    set-option window indentwidth 2
    map -docstring 'Clojure form'           window object f '<esc>: clojure-form-object-handler<ret>'
    map -docstring 'top-level Clojure form' window object t '<esc>: clojure-select-whole-toplevel-form<ret>'
}
